---
output:
  pdf_document: default
  html_document: default
---
# Management of genome-scale data with Bioconductor 

## Bioconductor Infrastructure: ExpressionSet and SummarizedExperimentSet 

* Similar classes of objects - expressionset usually array-based experiments and summarizedexperiment usually sequencing based experiments (rows = genomic ranges)
* Expression set lives in **Biobase** library 
* **GeoQuery** allows you to pull down expressionsets by name using GSE identifier. Downloads the expressionset of microarray data 
* List with single element in it - access element 
* Lots of metadata - **assayData**, **pheontypic data**, **experiment**, **anotations** 
* First sample - column indexing 
* first row or first feature - row indexing 
* Index by name 
* **pData** phenotypic data - information about columns of expression set 
* as.numeric on factor to see how many replicates of each strain 
* pData should have same # of rows as columns in the expression set 
* Feature data accessible with **FData** -- genes / probe sets. Gene ID, gene symbol 
* Experiment data and annotation data 
```{r}
library(Biobase)
library(GEOquery)

geoq <- getGEO("GSE9514")    # download a microarray dataset from GEO
names(geoq)    
e <- geoq[[1]]    # extract ExpressionSet
e

# exprs gives matrix of microarray values
dim(e)    # number of features and samples in ExpressionSet
ncol(e)
nrow(e)

exprs(e)[1:3,1:3]
head(exprs(e))[,1]    # first column
exprs(e)[1,]    # first row
exprs(e)["10000_at",]    # can also index by name
rownames(e)[1]    # row names are probe sets
dim(exprs(e))    # rows are features, columns are samples

# pData gives phenotype data (sample information)
pData(e)[1:3,1:6]
names(pData(e))
pData(e)$characteristics_ch1    # column in GEO to describe experimental state/condition
as.numeric(pData(e)$characteristics_ch1)    # help see replicates of each state
dim(pData(e))    # rows of pData correspond to columns of exprs
dim(e)

# fData gives feature data (probe information)
fData(e)[1:3,1:3]
dim(fData(e))    # rows of fData correspond to rows of exprs
names(fData(e))
head(fData(e)$"Gene Symbol")
head(rownames(e))

# additional annotation tied to ExpressionSet
experimentData(e)
annotation(e)
```

## Assessment: ExpressionSet 
```{r}
library(GSE5859Subset)
data(GSE5859Subset)
dim(geneExpression)
dim(sampleInfo)
dim(geneAnnotation)

identical(colnames(geneExpression), sampleInfo$filename)
identical(rownames(geneExpression), geneAnnotation$PROBEID)

pd = AnnotatedDataFrame(sampleInfo)
rownames(pd) = colnames(geneExpression)
experiment_date <- pData(pd)["GSM136530.CEL.gz","date"]
paste("experiment date: ", experiment_date)

varLabels(pd)

fd = AnnotatedDataFrame(geneAnnotation)
rownames(fd) = geneAnnotation$PROBEID
pData(fd)["204810_s_at", "CHR"]

eset = ExpressionSet(geneExpression,phenoData = pd,featureData = fd)
ind1 <- which(featureData(eset)$CHR == "chrY")
ind2 <- pData(eset)$group == 1
femaleY <- colMeans(exprs(eset)[ind1, ind2]) 
maleY <- colMeans(exprs(eset)[ind1, !ind2]) 
boxplot(maleY, femaleY)

median_diff=median(maleY) - median(femaleY)

paste("Difference in median expression of genes on the Y chromosome between maleY and femaleY: ", median_diff)
```

## Reading Microarray Raw Data: Single-Color Arrays 

* loading microArray data into R: Affymetrix one-color arrays and Agilent two-color 
* Affy package: parsers for reading in raw data files 
* *cel* files are raw data
* *sample info* files have table describing each sample 
* **pm** = perfect match probe-level intensities 
* columns of probe-level data will match the rows of pData - each row represents a sample and column matches sample. Rownames **pData** match colnames **pm** 
* Keep character which represents platform that the technology used 
* Bioconductor has a package which matches gene IDs to meaningful terms 
* Experiment data, sample information, third piece of information which connects us to other information which describes genes 
* Last step: turn into gene-level information --> probe level. Algorithm **rma** implemented in Bioconductor to do this using quantile normalization and background correction. 
* If only want gene expression data and not probe-level, you can use **justRMA** function to read and process in one shot

```{r}
wd <- getwd()
datadir <- paste0(wd, "/rawdata-master")    # downloaded files
basedir <- paste0(datadir, "/celfiles")
setwd(basedir)
library(affy)
tab <- read.delim("sampleinfo.txt",check.names=FALSE,as.is=TRUE)
rownames(tab) <- tab$filenames

tab
fns <- list.celfiles(basedir)
fns
fns %in% tab[,1] ##check
ab <- ReadAffy(phenoData=tab)

dim(pm(ab))
dim(pData(ab))
rownames(ab)
colnames(pm(ab))
annotation(ab)
```

## Agilent two-color Arrays 

* Package **limma** for two-color arrays
* Read in sample information - pairing of files to tell you what is red channel, what is green channel. Different scanners have different way of storing. 
* **lima** format is described in documentation - **readTargets** 
* **read.maimages** source which tells the package what imaging software was used to produce these files 
* **MA.RG** stores the log ratio of red and green 
* Function to look at images 
```{r}
# datadir defined in previous video
library(limma)
library(rafalib)
datadir <- paste0(wd, "/rawdata-master")    # downloaded files
basedir <- paste0(datadir, "/agilent")
setwd(basedir)
targets <- readTargets("TargetBeta7.txt")
RG <- read.maimages(targets$FileName, source="genepix")  # red and green 23k genes 

MA <- MA.RG(RG,bc.method="none")  # M and A, same information but transformed 
dim(RG$R)
dim(RG$G)
dim(MA$M)
dim(MA$A)
plot(MA$A[,1], MA$M[,1])    # MA plot for first sample

# microarray image
mypar(1,1)
imageplot(MA$M[,2], RG$printer, zlim=c(-3,3))
#dev.off()
```

## Assessment: Reading microarray data 

```{r}
library(hgu95acdf)

wd <- getwd()
datadir <- paste0(wd, "/rawdata-master")    # downloaded files
basedir <- paste0(datadir, "/celfiles")
setwd(basedir)
library(affy)
tab <- read.delim("sampleinfo.txt",check.names=FALSE,as.is=TRUE)
rownames(tab) <- tab$filenames

tab

level_gene_spike = tab[tab$filenames == "1521a99hpp_av06.CEL.gz", "36311_at"]
paste("level gene 36311_at spiked: ", level_gene_spike)

fns <- list.celfiles(basedir)

ab <- ReadAffy(phenoData=tab)

pn = probeNames(ab)
num_features_associated_w_gene=length(pn[pn == "36311_at"])

paste("number of features associated with gene 36311_at: ", num_features_associated_w_gene)

ab_sub <- ab[,ab$filenames %in% c("1532a99hpp_av04.CEL.gz", "1532b99hpp_av04.CEL.gz")]

probe_level_intensities = pm(ab_sub)
probeset_ids = which(pn == "36085_at")
probe_level_intensities_at_probeset = probe_level_intensities[probeset_ids,]

sample_metadata = pData(ab_sub)

par(mfrow=c(1, 2))
r_1 = log2(probe_level_intensities_at_probeset[,"1532a99hpp_av04.CEL.gz"]) / log2(sample_metadata[ "1532a99hpp_av04.CEL.gz", "36085_at"])
r_2 = log2(probe_level_intensities_at_probeset[,"1532b99hpp_av04.CEL.gz"]) / log2(sample_metadata[ "1532b99hpp_av04.CEL.gz", "36085_at"])
lmts <- range(r_1, r_2)
boxplot(r_1, main="1532a99hpp_av04.CEL.gz", ylim=lmts)
boxplot(r_2, main="1532b99hpp_av04.CEL.gz", ylim=lmts)
``` 

## SummarizedExperiment class 
* Similar to ExpressionSets but preferred for sequencing-based data 
* Accomodates experiments where genomic location is important 
* Most commonly used for NGS 
* **assay** function to access counts 
* **colData** equivalent to **pData** on ExpressionSet 
* rows correspond to genes - collections of exons (GRanges list used to count RNA sequencing reads)
* **metadata** how GRanges List was constructed and from what database etc. 
* **MIAME** minimal information about microarray experiment
```{r}
library(parathyroidSE)
data(parathyroidGenesSE)
se <- parathyroidGenesSE
se

# assay contains results of the assay
dim(se)
assay(se)[1:3,1:3]
dim(assay(se))    # rows = features (ranges), columns = samples

# colData contains sample information
colData(se)[1:3,1:6]
dim(colData(se))
names(colData(se))
colData(se)$treatment
as.numeric(colData(se)$treatment)

# rowRanges contains feature information
rowRanges(se)[1]
class(rowRanges(se))
length(rowRanges(se))    # number of genes
length(rowRanges(se)[[1]])    # number of exons for first gene
head(rownames(se))
metadata(rowRanges(se))

# additional metadata, including sample information
metadata(se)$MIAME
abstract(metadata(se)$MIAME)
```

## Assessment: SummarizedExperiment 

```{r}
library(airway)
data(airway)
metadata(airway)

dim(airway)

sample_metadata <- colData(airway)
sample_cell_line = sample_metadata["SRR1039509","cell"]
paste("Cell line associated with sample: ", sample_cell_line)

index_min = which.min(sample_metadata$avgLength)
sample_name <- rownames(sample_metadata[index_min,])
paste("Sample with shortest average read length: ", sample_name)

num_genes=length(rowRanges(airway))
paste("number of genes in dataset: ", num_genes)

g100_md <- rowRanges(airway)[[100]]
num_exons_g100 <- length(g100_md)
paste("number of exons at 100th gene: ", num_exons_g100)

total_bp_long_including_introns <- sum(width(range(g100_md)))
paste("number of bases long of 100th gene (including introns): ", total_bp_long_including_introns)
tssgr <- resize(range(rowRanges(airway)[[100]]), 1)
tss <- start(tssgr)
paste("transcription start site of 100th gene: ", tss)

expr <- assay(airway)["ENSG00000103196",]
mean_expr <- mean(expr)
paste("mean expression of ENSG00000103196 across all samples: ", mean_expr)

samples_treated_w_dex <- rownames(sample_metadata[which(sample_metadata$dex == "trt"),])
expr_treated <- subset(expr, names(expr) %in% samples_treated_w_dex)
mean_expr_treated <- mean(expr_treated)
paste("mean expression of ENSG00000103196 across all samples treated with dex: ", mean_expr_treated)

expr_untreated <- subset(expr, !names(expr) %in% samples_treated_w_dex)
mean_expr_untreated <- mean(expr_untreated)
paste("mean expression of ENSG00000103196 across all samples not treated with dex: ", mean_expr_untreated)

log_ratio_trt_untrt <- log2(mean_expr_treated / mean_expr_untreated)
paste("log ratio of mean expression between treated and untreated: ", log_ratio_trt_untrt)

```