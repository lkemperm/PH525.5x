---
output:
  pdf_document: default
  html_document: default
---
# Bioconductor Basics: Granges and Biostrings

* Core Bioconductor structures for representing genes and genetic sequences 

## Motivation and Introduction

* Case study: given genomic DNA extracted from human cells, where on the genome does the nuclear protein ESRRA (estrogen related receptor alpha) bind? 
* Role of estrogen receptors in breast cancer 
* Data comes from analysis of ChIP-seq experiments: performed in ENCODE project - import info for files in "narrowPeak" format and analyze in Bioconductor GRanges object 
* Identifying nearest transcriptional start site for each binding peak - assess whether regulatory activity of ESRRA occurs in transcriptional promoter regions 

```{r}
library(ERBS)
data(HepG2)
class(HepG2)
```

## GenomicRanges 

* ERBS library from github repo 
* Load two datasets - GM12878, HepG2. Estrogen receptor binding site datasets from two cell lines (cell-type dependent outcome). 
* Contains: Chromosome start + end (1 row / region), strand information, score from peaks 
* Access the GRanges objects as a matrix, i.e. subsetting is okay. 
* **seqnames** function to access chromosome for each row. Returns object of type *Rle* - more efficient to save ordered by chromosome with counts. Can turn into character using **as.character**
* Most of analysis is focused on first 23 chromosomes 
* Function to order by genomic region
* Iranges function not specific to genomics - Granges builds on Iranges in relation to genomics 

```{r}
# install ERBS
library(devtools)
install_github("genomicsclass/ERBS")

library(GenomicRanges)

# load GM12878 and HepG2 objects from ERBS package
library(ERBS)
data(GM12878)
data(HepG2)

# inspect HepG2 GRanges object
class(HepG2)
HepG2
values(HepG2)

# seqnames extracts chromosome names
seqnames(HepG2)     # stored as type Rle
chr = seqnames(HepG2)
as.character(chr)    # view as character type

# make a table of numbers of sequences on each chromosome
table(chr)
table(chr)[1:24]    # restrict to autosomes, X and Y

# GRanges can be subsetted and ordered
HepG2[chr=="chr20",]
x = HepG2[order(HepG2),]
seqnames(x)     # demonstrate usefulness of Rle type
as.character(seqnames(x))
```

### Assessment: Genomic Ranges 

```{r}
library(GenomicRanges)
paste("median of signal value column for HepG2 data: ")
median(mcols(HepG2)$signalValue)

paste("chromosome in region with highest signal value: ")
max_index <- which.max(mcols(HepG2)$signalValue)
chr = seqnames(HepG2)
as.character(chr)[max_index]

paste("Number of regions from chromosome 16: ")
HepG2[chr == "chr16",]

hist(width(HepG2))

median_width <- median(width(HepG2))
paste("Median width of all chromosomes: ", median_width)
```

## Bioconductor Infrastructure for genomics, microarray and NGS 

* IRanges package - representing ranges of integers. Base pair arrangements we want to manipulate in genomics 
* Vignette about classes and functions in IRanges package 
* Simple functions have good performance 
* Summary of most important functions
* IRanges - start, end, width (i.e., 5, 10, 6bP long)
* Start, end, and width functions 
* Can specify > 1 range at a time to make IRanges objects of length n 
* Intra-range methods: 

* **Shift** - Intra range methods for IRanges - doesn't depend on other ranges contained in IRanges object. I.e., shift IRange to the left by 2. 
* **Narrow** - relative to start, start at nth base pair 
* **Flank** - get flanking sequence 3 base pairs from start or end (start = False). Also bi-directional (both=True)

* Inter-range methods: 

* **range** - will give beginning of the IRanges to the end, including gaps in between 
* **reduce** - gives us base pairs covered by the original ranges (do not get gaps). Can ask for gaps. 
* **disjoint** - set of ranges which has the same coverage as original IRanges object but non-overlapping. Contain union of all endpoints of the original range. 

### Assessment: IRanges 
```{r}
library(IRanges)
ir <- IRanges(101, 200)
paste("*2 zooms in, giving range with half the width. New starting point: ", start(ir*2))
n_ir <- narrow(ir, start=20)
paste("narrow function with start of 20. New starting point: ", start(n_ir))
paste("+25 operation gives width of resulting range: ", width(ir+25))

m_ir <- IRanges(start=c(1, 11, 21),end=c(3, 15, 27))
paste("sum of widths of multiple IRanges objects:", sum(width(m_ir)))

x <- IRanges(start=c(101,106,201,211,221,301,306,311,351,361,401,411,501), end=c(150,160,210,270,225,310,310,330,390,380,415,470,510))
library(ph525x)
plotRanges(x)
paste("Total width not covered by ranges in x:", sum(width(gaps(x))))

paste("Number of disjoint ranges within ranges in x:", length(disjoin(x)))

par(mfrow=c(2, 1))
plotRanges(x, xlim=c(0, 600))
plotRanges(resize(x, 1), xlim=c(0, 600))
```


## Genomic ranges: GRanges 

* Extension of IRanges 
* Contain a sequence name - IRange of chromosome Z. 
* Can contain chromosome information and sequence length 
* Sequence names as Rle 
* IRanges and strange as Rle also 
* Can shift similar to IRanges - will go off end of chromosome if exceeds length 
* Wrap in trim function to make sure that the end at chromosome end does not exceed 
* Metadata accessed with *mcols* 
* Can add cols by *mcols$* 
* Additional package called *GRangesList* - groups GRanges together by wrapping in function call 
* Example of *GRangesList* - grouping exons by gene or by transcript 
* Application of package - find overlaps between GRanges objects 
* *findOverlaps* function - query and subject (see in help() function)
* output of *findOverlaps* is a hits object with length representing # overlaps 
* Same way to get the overlaps is *%over%* function - which returns logical vector 
* *Rle* object defined by IRanges but similar object in base R = Run length encoding 
* If vector repeats certain values, can save memory by number and number of times repeated 
* *str* function gives us the compact representation 
* Peering into *Rle* object - can use *Views* object to see *IRanges* from start to end. Only a virtual class - saves *Rle* and number of views / windows into it 
* Can also use for *Fasta* files or other objects 

### Assessment: GRanges 
* GRanges object extends concept of interval ranges 
* Ranges can be defined by: 
   * chromosome we are referring to (seqnames in Bioconductor)
   * strand of DNA we are referring to (+ or -)
* These two pieces of information are necessary for specification of a range of DNA
```{r}
library(GenomicRanges)
library(IRanges)
library(ph525x)
x = GRanges("chr1", IRanges(c(1,101),c(50,150)), strand=c("+","-"))
paste("Get the internal IRanges from a GRanges object: ")

plotGRanges = function(x) plotRanges(ranges(x))
plotGRanges(x)
plotGRanges(resize(x, 1))
paste("Result of running resize(x, 1) is two ranges of width 1 which start at left-most point of the + strand ranges in x, 
      and the right-most point of the - strand ranges in x (+ -> -)")

paste("Q2: Intersecting transcripts with basic operations")

x = GRanges("chr1", IRanges(c(101, 201, 401, 501), c(150, 250, 450, 550)), strand="+")
y = GRanges("chr1", IRanges(c(101, 221, 301, 401, 541), c(150, 250, 350, 470, 550)), strand="+")
par(mfrow=c(2,1))
plotGRanges(x)
plotGRanges(y)
multiple_granges_list <- GRangesList(x,y)
single_granges_list <- GRangesList(c(x, y))

findOverlaps(x, y)

paste("width of overlap between x and y: ", sum(width(union(x, y))) - sum(width(intersect(x, y))))

z = GRanges("chr1", range(ranges(x)), strand="-")

```
## Operating on GRanges 

* Small set of ranges = intervals on chromosome 
* Operations: 
  * *reduce* - project all of the occupied bases into contiguous intervals and leaves empty parts with no coverage 
  * *disjoin* - set of intervals / ranges generated by disjoin of set of ranges. Same occupancy as original GRanges object 
    * Maximal complexity set of intervals where wherever there was an endpoint, we will not cross in a set of ranges. 
  * *gap* - set xlim to show the regions that are never expressed. could be regarded as introns, spliced out. (gaps of exons are introns)
* Elaborate the set of intervals by turning it into a GRanges object by specifying seqnames and range information. 
* Metadata that should be specified - strand information, genome, seqlengths, seqinfo 
* How to pick out transcription start sites - plot overlapping genes. Resize with argument 1 to get down to one base from start. Gives us the addresses of start sites 
* Finding promoters - interval of three bases upstream of bases upstream is regarded as a promoter. Use *flank* operation with argument 3 - gives us the locations of the upstream promoters. Use start=FALSE to indicate flank at the end of the interval rather than start. 

## Finding Overlaps 
* Example: finding genes that are close to reported binding sites and add some annotation to those genes 
* HepG2 + GM12878 - reported binding sites for 2 cell lines 
* Want to find the genes that are nearest to them. Instead of seperately, create a consensus GRanges which includes only sites that are common to both GRanges 
* Function: *findOverlaps* uses query and subject - for each range, see if it appears in another range and return pair. Returns object of class *hits*. Only want the ones where there is a hit - use *queryHits* function and subset based on queryHits 
* Extract just region information using *granges* function
* Show extraction of genes in next video, and matching of the regions in ERBS dataset to genes 
```{r}
# load packages
library(GenomicFeatures)
library(GenomicRanges)
library(IRanges)
library(ERBS)

# load ESRRA ChIP data
data(HepG2)
data(GM12878)

# browseVignettes("GenomicRanges")

# find binding sites common to both HepG2 and GM12878
?findOverlaps
# for each row in query, return overlapping row in subject
res = findOverlaps(HepG2, GM12878)
class(res)
res

# ranges from the query for which we found a hit in the subject
index = queryHits(res)
erbs = HepG2[index,]
erbs

# extract only the ranges
granges(erbs)
erbs
```

## Assessment: Finding Overlaps
```{r}
library(ERBS)
data(HepG2)
data(GM12878)
paste("17th region of HepG2 starts at:", start(granges(HepG2[17])))

dtn <- distanceToNearest(HepG2[17], GM12878)
gm_idx <- subjectHits(dtn)
start_site <- start(GM12878[gm_idx])
distance_to_closest = mcols(dtn)$distance
paste("Start site of closest region to 17th region of HepG2: ", start_site)
paste("Distance between closest region to 17th region of HepG2: ", distance_to_closest)
X <- vector(mode="integer", length=length(HepG2))
for(i in seq_along(HepG2)) {
     closest_region = distanceToNearest(HepG2[i], GM12878)
     distance = mcols(closest_region)$distance
     X[i] = distance
}
proportion_lt_2k_bp <- length(X[X < 2000]) / length(X)
paste("proportion of distances < 2000 bp: ", proportion_lt_2k_bp)
```

## Genes as GRanges

* Mapping genes to binding sites 
* Load Gene information from homo sapiens library and extract genes using function called **genes** - returns GRange 
```{r}
library(Homo.sapiens)
library(ERBS)
ghs = genes(Homo.sapiens)

res = precede(erbs, ghs)
res

ghs[res[1:3]]

```
* Start and end of genes - series of locations. Also have ID used by Homo sapiens database to match gene info across different databases 
* Gene with ID 1 is in chromosome 19. Start defined in IRanges. 
* **strand** tells you which of two DNA strands the gene is on. When gene expression happens, DNA opens up and code for gene could be in either strand. 
* Movement of the transcription is going in a certain direction 
* Large -> small if -, small -> large if -. 
* Transcription start site - depends on strand information 
* Function from **GenomicRanges** package called **precede** - tells you what is ahead of the transcription start site which varies depending on strand 
* Finds entry and query closest to subject only when in front of. 
* Moving towards report on which genes are closest to binding sites 

## Assessment: Genes as GRanges 

```{r}
library(Homo.sapiens)
ghs = genes(Homo.sapiens)
number_of_genes <- length(ghs)

paste("number of genes represented: ", number_of_genes)
chr_most_genes <- names(which.max(table(as.vector(seqnames(ghs)))))
paste("chromosome with most genes: ", chr_most_genes)

hist(width(ghs), nc=1000)

median_width <- median(width(ghs))

paste("median gene width: ", median_width)

```

## Finding the Nearest Gene 

* Compute distance between each binding site and corresponding gene found with precede, use **distance** function 
* Takes two GRanges objects, and the genes we have found with precede
* We expect overlaps, however will not show up because we are requiring binding sites precede the genes 

```{r}
library(Homo.sapiens)
ghs = genes(Homo.sapiens)
library(ERBS)
index = precede(erbs, ghs)
ghs[index[1:3]]
erbs[1:3]

distance(erbs, ghs[index])

tssgr = resize(ghs, 1) # shrink down to one going in direction towards transcription start site, aware of strand 
tssgr
d=distanceToNearest(erbs, tssgr)

queryHits(d)
dists = values(d)$distance
hist(dists,nc=1000,xlim=c(0,100000))

index = subjectHits(d)[dists < 1000]
index


```
* define another distance: ask for each binding site, find the transcription start site that is closest 
* For each of our binding sites, find the closest transcription start site using **distanceToNearest**. Finds distance to nearest given query and subject 
* Now, we have zeros because there is overlap. Output is a **hits** object. Need to use **queryHits** rather than subsetting. 
* For distance, use **values** function to extract columns and grab distance 

* Index of genes that are closest using **subjectHits** 
* Find genes that are closer than 1k to binding sites 
* Use genes that were found to be close, and get further information 


## Annotating Genes 
* Use **select** function to query Homo sapiens database 
* Need to give: key, columns we want to look at, key type 
* Example of going from ranges to list of interesting genes 


```{r}
library(Homo.sapiens)
library(ERBS)
ghs = genes(Homo.sapiens)
tssgr = resize(ghs, 1) # shrink down to one going in direction towards transcription start site, aware of strand 
d=distanceToNearest(erbs, tssgr)
dists = values(d)$distance
index = subjectHits(d)[dists < 1000]
tssgr[index,]
keytypes(Homo.sapiens)
keys = as.character(values(tssgr[index])$GENEID)
columns(Homo.sapiens)
res = select(Homo.sapiens, keys = keys,
             columns = c("SYMBOL", "GENENAME"), keytype="GENEID")
res[1:2,]
```

## Assessment: Finding and getting annotation for closest gene

* Find the closest genes to some of our binding sites - use consensus set of regions 

```{r}

library(ERBS)
data(HepG2)
data(GM12878)
res = findOverlaps(HepG2,GM12878)
erbs = HepG2[queryHits(res)]
erbs = granges(erbs)

erbs2= intersect(HepG2,GM12878)

erbs

erbs2 

library(Homo.sapiens)
ghs = genes(Homo.sapiens)

transcription_start_site=resize(ghs["100113402"], 1)
paste("transcription start site for gene id 100113402: ", transcription_start_site)


library(ERBS)
data(HepG2)
data(GM12878)
res = findOverlaps(HepG2,GM12878)
erbs = HepG2[queryHits(res)]
erbs = granges(erbs)
index = nearest(erbs[4], tssgr)
index
gene_id <- names(tssgr[index,]$GENEID)

paste("gene id with TSS closest to 4th region of erbs: ", gene_id)
keys = as.character(values(tssgr[index])$GENEID)
symbol_of_gene <- select(Homo.sapiens, keys=keys, columns=c("SYMBOL"), keytype="GENEID")
paste("Symbol of gene id: ", symbol_of_gene$SYMBOL)

```